snippet beg "block delimiter"
begin
	${0}
end
endsnippet

snippet if "if statement"
if (${1}) begin
	${0}
end
endsnippet

snippet ife "If/else statements"
if(${1}) begin
	${2}
end else begin
	${3}
end
endsnippet

snippet eif "Else if statement"
else if(${1}) begin
	${2}
end
endsnippet

snippet el "Else statement"
else begin
	${0}
end
endsnippet

snippet wh "While statement"
while (${1}) begin
	${0}
end
endsnippet

snippet rep "Repeat Loop"
repeat (${1}) begin
	${0}
end
endsnippet

snippet ca "Case statement"
case (${1:/* variable */})
	${2:/* value 0 */} : ${3}
	${4:/* value 1 */} : ${5}
	default : ${6}
endcase
endsnippet

snippet casez "CaseZ statement"
casez (${1:/* variable */})
	${2:/* value */}: begin
		${3}
	end
	default: begin
		${4}
	end
endcase
endsnippet

snippet alw "Combinational Always block"
always @(*) begin
	${1}
end
endsnippet

snippet al "Sequential logic Always block"
always @(posedge clk, negedge ${2:rst_n}) begin
	if(!$2) begin
		${1}
	end ${0}
end
endsnippet

snippet ass "assignment""
assign  ${1} = ${2};
endsnippet

snippet mod "Module block"
module ${1:`!v expand("%:t:r")`} (${2});
	${0}
endmodule // $1
endsnippet

snippet for "For"
for (int ${2:i} = 0; $2 < ${1:count}; $2${3:++}) begin
	${4}
end
endsnippet

snippet forev "Forever"
forever begin
	${0}
end
endsnippet

snippet fun "Function"
function ${1:void} ${2:name}(${3});
	${0}
endfunction: $2
endsnippet

snippet task "Task"
task ${1:name}(${2});
	${0}
endtask: $1
endsnippet

snippet ini "Initial "
initial begin
	${0}
end
endsnippet

snippet tdsp "typedef struct packed"
typedef struct packed {
	int ${2:data};
} ${1:`!v expand("%:t:r")`};
endsnippet

snippet tde "typedef eum"
typedef enum ${2:logic[15:0]}
{
	${3:REG = 16'h0000}
} ${1:my_dest_t};
endsnippet

snippet forea "Foreach Loop"
foreach (${1}) begin
	${0}
end
endsnippet

snippet dowh "Do-while statement"
do begin
	${0}
end while (${1});
endsnippet

snippet alc "Combinational always block"
always_comb begin ${1:: statement_label}
	${0}
end $1
endsnippet

snippet alff "Sequential logic"
always_ff @(posedge ${1:clk}) begin ${2:: statement_label}
	${0}
end $2
endsnippet

snippet all "Latched logic"
always_latch begin ${1:: statement_label}
	${0}
end $1
endsnippet

snippet cl "Class"
class ${1:class_name};
	// data or class properties
	${0}

	// initialization
	function new();
	endfunction : new

endclass : $1
endsnippet

snippet types "Typedef structure"
typedef struct {
	${0}
} ${1:name_t};
endsnippet

snippet prog "Program block"
program ${1:program_name} ();
	${0}
endprogram : $1
endsnippet

snippet intf "Interface block"
interface ${1:program_name} ();
	// nets
	${0}
	// clocking

	// modports

endinterface : $1
endsnippet

snippet clock "Clocking Block"
clocking ${1:clocking_name} @(${2:posedge} ${3:clk});
	${0}
endclocking : $1
endsnippet

snippet cg "Covergroup construct"
covergroup ${1:group_name} @(${2:posedge} ${3:clk});
	${0}
endgroup : $1
endsnippet

snippet pkg "Package declaration"
package ${1:package_name};
	${0}
endpackage : $1
endsnippet

